pub mod math;
pub struct Weight(f64);

pub struct Neuron {
    pub weight: Weight,
}

#[derive(Debug, Clone)]
pub struct Matrix {
    array: Vec<f64>,
    pub width: usize,
    pub height: usize,
}

impl Matrix {
    pub fn new(array: Vec<f64>, width: usize, height: usize) -> Self {
        Self {
            array,
            width,
            height,
        }
    }
    pub fn transpose(&mut self) {
        // Step 1: Create a new vector to store the transposed matrix
        let mut output = self.array.clone();

        // Step 2: Iterate over the rows and columns of the original matrix
        for x in 0..self.width {
            for y in 0..self.height {
                /*
                 * Step 3: Swap the elements from the original matrix
                 *         to the corresponding position in the transposed matrix
                 *
                 * Example:
                 * Original matrix:
                 *  1 2 3
                 *  4 5 6
                 *
                 * Transposed matrix:
                 *  1 4
                 *  2 5
                 *  3 6
                 *
                 * To transpose the matrix, we swap the elements at positions (x, y) and (y, x)
                 * in the original matrix to the corresponding positions in the transposed matrix.
                 */
                output[y + x * self.height] = self.array[x + y * self.width];
            }
        }

        // Step 4: Update the original matrix with the transposed matrix
        self.array = output;

        // Step 5: Swap the width and height of the matrix to reflect the transposed dimensions
        let old_width = self.width;
        self.width = self.height;
        self.height = old_width;
    }
pub fn transpose_in_place(&mut self) {

        // Step 1: Iterate over the rows and columns of the original matrix
        for x in 0..self.width {
            for y in 0..self.height {
                /*
                 * Step 2: Swap the elements in place
                 *
                 * Example:
                 * Original matrix:
                 *  1 2 3
                 *  4 5 6
                 *
                 * Transposed matrix:
                 *  1 4
                 *  2 5
                 *  3 6
                 *
                 * To transpose the matrix, we swap the elements at positions (x, y) and (y, x)
                 *
                 */
               self.array.swap(y + x * self.height ,x + y * self.width);
            }
        }

        let old_width = self.width;
        self.width = self.height;
        self.height = old_width;
    }


    pub fn dot(a: &Matrix, b: &Matrix) -> Matrix {
        // Step 1: Check if the matrices are compatible for multiplication
        if a.width != b.height {
            panic!("Matrices are not compatible for multiplication");
        }

        // Step 2: Create a new vector to store the result of matrix multiplication
        let mut result = Vec::with_capacity(a.height * b.width);

        /*
         * Step 3: Iterate over the rows of the first matrix (a) and
         *         the columns of the second matrix (b)
         *
         * To compute the matrix multiplication, we need to calculate the dot product
         * of each row in the first matrix (a) with each column in the second matrix (b).
         *
         * Example:
         * Matrix A:
         *  1 2
         *  3 4
         *
         * Matrix B:
         *  5 6
         *  7 8
         *
         * Resulting matrix (A * B):
         *  (1*5 + 2*7)   (1*6 + 2*8)
         *  (3*5 + 4*7)   (3*6 + 4*8)
         *
         *  =  19 22
         *     43 50
         */
        for i in 0..a.height {
            for j in 0..b.width {
                let mut sum = 0.0;
                for k in 0..a.width {
                    /*
                     * Step 4: Calculate the dot product of the row from matrix a
                     *         and the column from matrix b
                     *
                     * The dot product is calculated by multiplying the elements
                     * at the same position in the row and column, and summing
                     * the products.
                     */
                    sum += a.array[i * a.width + k] * b.array[k * b.width + j];
                }
                // Step 5: Store the dot product in the result vector
                result.push(sum);
            }
        }

        /*
         * Step 6: Create a new Matrix instance with the result vector
         *         and the appropriate dimensions (b.width for width and a.height for height)
         */
        Matrix::new(result, b.width, a.height)
    }
}

